# Функции

## Функция
* Функция является способом группирования набора операторов, позволяющим
выполнять их более одного раза в программе - упакованной процедурой, вызываемой по имени. Функции способны вычислять результирующее значение и
также дают возможность указывать параметры, которые служат входными данными
функции и могут отличаться при каждом выполнении кода. Кодирование операции
как функции делает ее в целом полезным инструментом, который можно
использовать в разнообразных контекстах

#### Роль функции
* Доведение до максимума многократного использования кода и сведение к минимуму избыточности
* Процедурная декомпозиция (функции предлагают инструмент для разбиения систем на части с хорошо определенными ролями.)

#### Операторы и выражения, связанные с функциями:
* **def (async def)** - является исполняемым кодом, создает объект и присваивает его имени
* **return** - отправляет результирующий объект вызывающему коду
* **yield** - отправляет результирующий объект вызывающему коду, запоминает место, где он остановился
* **global** - объявляет переменные уровня модуля, предназначенные для присваивания
* **nonlocal** (Python З.Х) - объявляет переменные объемлющей функции, предназначенные для присваивания
* **lambda** - создает объект, возвращает его в качестве результата

#### Аргументы функций:
* **Позиционные** `def func(arg1, arg2, ... argN)`: сопоставляются слева направо 
* **Ключевые**: `def func(name1=value1, name2=value2, ... nameN=valueN)` сопоставляются по имени аргумента
* **Сбор переменного количества аргументов** `def func(*args)`: собирает произвольно много позиционных и ключевых аргументов
* **Распаковка переменного количества аргументов** `def func(**kwargs)`: передает произвольно много позиционных и ключевых аргументов


#### Общий вид
```
def func(arg1, arg2, ... argN, *arg, name1=value1, name2=value2, **kwargs):
    
    return arg


def func(arg1, arg2, ... argN, *arg, name1=value1, name2=value2, **kwargs):
    
    yield arg
```

# Аннотации типов

#### PEP регламентирующие работу с аннотациями
* [PEP 3107 — Function Annotations](https://www.python.org/dev/peps/pep-3107/)
* [PEP 484 — Type Hints](https://www.python.org/dev/peps/pep-0484/)
* [PEP 526 — Syntax for Variable Annotations](https://www.python.org/dev/peps/pep-0526/)
* [PEP 563 — Postponed Evaluation of Annotations](https://www.python.org/dev/peps/pep-0563/)

#### Общий вид функции с аннотациями
```
def func(s: str, n: int) -> str:
   return s * n
```
* Доступ к использованным в функции аннотациям можно получить через атрибут 
__annotations__, в котором аннотации представлены в виде словаря, 
где ключами являются атрибуты, а значениями – аннотации. Возвращаемое функцией 
значение хранится в записи с ключом return.

```
func.__annotation__
```

#### Аннотация переменных
```
var = value # type: annotation
var: annotation; var = value
var: annotation = value
```

#### Примеры использования аннотаций
```
# список
scores: List[int] = []
scores.append(1)

# кортеж
pack: Tuple[int, …] = (1, 2, 3)

# логическая переменная
flag: bool
flag = True

# класс
class Point:
    x: int
    y: int
    def __init__(self, x: int, y: int):
         self.x = x
         self.y = y
```

#### Принципы проектирования функций.
* Связность: используйте аргументы для входных данных и оператор return для 
выходных данных. Как правило, вы должны стремиться сделать функцию независимой 
от вещей, находящихся за ее пределами.
* Связность: применяйте глобальные переменные, только когда они по-настоящему нужны.
* Связность: не модифицируйте изменяемые аргументы, если только такое изменение
не ожидается вызывающим кодом.
* Сцепление: каждая функция должна иметь единственное унифицированное
назначение. При надлежащем проектировании каждая функция должна делать
что-то одно - то, что может быть резюмировано в простом повествовательном
предложении.
* Размер: каждая функция должна быть относительно небольшой.
* Связность: избегайте прямого изменения переменных из другого файла модуля.

#### Рекурсивные функции
```
def func(s: str, n: int) -> str:
    s = s * n
    return func(s, n)
```

#### Анонимные функции: выражения lambda

```
lambda arg1, arg2, ... argN: выражение, использующее аргументы
```
* lambda представляет собой выражение, а не оператор. По этой причине выражение 
lambda может находиться в местах, где оператор def не разрешен синтаксисом 
Python — скажем, внутри спискового литерала или в аргументах вызова функции. 
В случае def на функции можно ссылаться по именам, но они должны быть созданы 
где-то в другом месте. Как выражение, lambda возвращает значение 
(новую функцию), которую дополнительно можно присвоить имени. Напротив, 
оператор def всегда присваивает новую функцию имени в своем заголовке вместо 
возвращения ее в виде результата.
* Тело lambda является одиночным выражением, а не блоком операторов. Тело
lambda похоже на то, что было бы указано в операторе return внутри тела def; 
вы просто набираете результат как обычное выражение, не возвращая его явно. 
Из-за ограничения только выражением тело lambda менее универсально, чем def — 
вы можете помещать в тело lambda лишь определенную логику, не использующую 
операторы вроде if. Так было задумано, чтобы ограничить вложенность 
в программе: выражение lambda предназначено для записи простых функций, 
а оператор def поддерживает более крупные задачи.

```
def func(x, у, z): 
    return x + у + z


f = lambda х, у, z: х + у + z
```

## Области видимости

Python создает, изменяет или ищет имя внутри того, что называется 
**пространством имен** — месте, где имена существуют. Когда речь идет о поиске 
значения имени применительно к коду, термин область видимости относится к
пространству имен: т.е. местоположение присваивания имени в исходном коде 
определяет область, где имя является видимым для кода.

* Имена, присвоенные внутри def, могут быть видны только в коде внутри этого
оператора def. Ссылаться на такие имена извне функции нельзя.
* Имена, присвоенные внутри def, не конфликтуют с переменными за пределами def,
даже если те же самые имена применяются где-то в другом месте.

* если переменная присваивается внутри def, то она будет локальной в 
этой функции;
* если переменная присваивается в объемлющем def, тогда она будет нелокальной 
в отношении вложенных функций;
* если переменная присваивается за пределами всех def, то она будет глобальной
в целом файле.

Функции определяют локальную область видимости, а модули — глобальную область 
видимости со следующими свойствами:
* Включающий модуль является глобальной областью видимости. Для внешнего мира 
глобальные переменные становятся атрибутами объекта модуля после его 
импортирования, но могут также использоваться в качестве простых переменных 
внутри самого файла модуля.
* Глобальная область видимости охватывает только одиночный файл
* Присвоенные имена являются локальными, если только не объявлены глобальными 
или нелокальными.
* Все остальные имена представляют собой локальные, глобальные или встроенные 
в объемлющей функции. Предполагается, что имена, которым не присваиваются 
значения в определении функции, являются локальными именами в объемлющей 
области видимости, которые определены в окружающем операторе; 
глобальными именами, существующими в пространстве имен включающего модуля; 
или встроенными именами в предварительно определенном модуле builtins, 
предоставляемом Python.
* Каждый вызов функции создает новую локальную область видимости.

```
import builtins
dir(builtins)
```

## Операторы global, nonlocal

* оператор **global** дает возможность изменять имена, которые существуют вне 
def на верхнем уровне файла модуля.
```
X = 88  # Глобальная переменная X


def func():
    global X
    X = 99  # Глобальная переменная X: снаружи def


func()
print(X)  # Выводит 99


y, z = 1, 2  # Глобальные переменные в модуле


def all_global():
    global x  # Объявление присваиваемой глобальной переменной
    x = y + z  # Объявлять у, z не нужно: правило LEGB (local, enclosing, global, built-in)


all_global()
print(x)
```
* оператор **nonlocal** почти идентичен, но применяется к именам в локальной 
области видимости объемлющего оператора def, а не к именам во включающем модуле.

```
def tester(start):
    state = start

    def nested(label):
        print(label, state)
        state += 1  # По умолчанию изменять нельзя (в Python 2.Х вообще никогда)

    return nested


F = tester(0)
F('spam')


def tester(start):
    state = start  # Каждый вызов получает собственное значение state

    def nested(label):
        nonlocal state  # Запоминает из объемлющей области видимости
        print(label, state)
        state += 1  # Нелокальную переменную разрешено изменять

    return nested
```

## Задание:
* написать не меньше 5 функций, которе выполняют разные задачи, но применяются в одной области:
  * хотя бы одна функция должна принимать позиционные и именованные параметры
  * хотя бы одна функция должна использовать оператор **nonlocal** или **global**
  * хотя бы одна функция должна использовать аннотацию переменных
  * применить lambda выражение и инструкцию yield
* Выбор области, для которой будут написаны функции, на выбор программиста (картинки, математика, ИИ, приготовление пищи и т.д.)